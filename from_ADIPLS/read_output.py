"""
Assumes the following ADIPLS parameters
nfmode=2
"""

import scipy.io
import numpy as np

class Mode():
	def __init__(self, f, nnw):
		"""
		Assumes nfmode=2 (see point 8.4.b of adiab.prg.v0_3.pdf). According to equation 2.5a of adiab.prg.v0_3.pdf, y_1 is the radial displacement and y_2 is (proportional to) the horizontal displacement.
		
		Arguments:
			f: a file handle generated by scipy.io.FortranFile
			nnw: int, number of mesh points used by ADIPLS
		"""
		
		cs, ics, y = f.read_record("(38,)<f8", "(24,)<i4", f"({nnw},2)<f8")
		
		self._cs = cs
		self._ics = ics[:12]
		self.y = y
		
		G = 6.67408e-11 * 1e2**3 * 1e-3 #CGS units: cm^3 g^{-1} s^{-2}
		
		#NOTE: see section 8.2 of adiab.prg.v0_3.pdf for the meaning of the various elements of cs and ics
		M = cs[1]
		R = cs[2]
		self.l = cs[17]
		self.n = int(cs[18])
		sigma2 = cs[19]
		
		self.nordp = ics[8]
		self.nordg = ics[9]
		self.m = ics[10]
		
		#'Derived' quantities
		self.n_nodes = self.nordp + self.nordg
		self.omega = np.sqrt(sigma2*G*M/R**3)

def read_modes(filename):
	"""
	The eigenfunction output is described in section 8.4 of adiab.prg.v0_3.pdf.
	
	This function assumes nfmode=2 (see point 8.4.b of adiab.prg.v0_3.pdf).
	
	In `adipls.c.d.f`, the comments (search for `idsefn`) say that the write is as an unformatted Fortran file. In F77, there is only one integer type 'i4', a 4-byte int; there are two float types, 4-byte ('f4') and 8-byte ('f8')
		
	Returns:
		x: fractional radius (mesh coordinates for the eigenfunctions)
		modes: list of Mode instances
	"""
	with scipy.io.FortranFile(filename) as f:
		nnw, *_ = f.read_record("i4")

	with scipy.io.FortranFile(filename) as f:
		_, x = f.read_record("i4", f"({nnw},)<f8")
		
		modes = []
		while True:
			try:
				modes.append(Mode(f, nnw))
			except scipy.io.FortranEOFError:
				break

	return x, modes

if __name__ == "__main__":
	import matplotlib.pyplot as plt
	
	x, modes = read_modes("amde.l9bi.d.202c.prxt3")
	
	#Some sanity checks
	css = np.array([mode._cs[1:7] for mode in modes])
	assert np.all(np.equal(css, css[0])) #stellar mass etc should not be mode-dependent.

	#Plot the found modes
	fig,ax = plt.subplots()
	ax.scatter([mode.l for mode in modes], [mode.omega*1e3 for mode in modes], s=3**2)
	ax.set_ylabel(r"$\omega$ (mHz)")
	ax.set_xlabel(r"$\ell$")

	plt.show()
